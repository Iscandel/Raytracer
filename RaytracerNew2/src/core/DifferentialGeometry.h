#pragma once

#include "Geometry.h"

///////////////////////////////////////////////////////////////////////////////
/// \brief Stores differential geometry data related to an intersection point.
///////////////////////////////////////////////////////////////////////////////
class DifferentialGeometry
{
public:
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW

public:
	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	DifferentialGeometry();

	///////////////////////////////////////////////////////////////////////////
	/// \brief Constructs a local coordinate system from a single vector.
	///////////////////////////////////////////////////////////////////////////
	DifferentialGeometry(const Normal3d& n)
	{
		myN = n;
		coordinateSystem(myN, myS, myT);
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	~DifferentialGeometry();

	///////////////////////////////////////////////////////////////////////////
	/// \brief Constructs a local coord system from 3 vectors.
	///////////////////////////////////////////////////////////////////////////
	static void coordinateSystem(const Vector3d &a, Vector3d &b, Vector3d &c) {
		if (std::abs(a.x()) > std::abs(a.y())) {
			real invLen = 1.0f / std::sqrt(a.x() * a.x() + a.z() * a.z());
			c = Vector3d(a.z() * invLen, 0.0f, -a.x() * invLen);
		}
		else {
			real invLen = 1.0f / std::sqrt(a.y() * a.y() + a.z() * a.z());
			c = Vector3d(0.0f, a.z() * invLen, -a.y() * invLen);
		}
#ifdef USE_ALIGN
		b = c.cross3(a);
#else
		b = c.cross(a);
#endif
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	Vector3d toLocal(const Vector3d& v) const
	{
		return Vector3d(v.dot(myS), v.dot(myT), v.dot(myN));//.normalized(); //normalize for rounded errors...
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	Vector3d toWorld(const Vector3d& v) const
	{
		return (myS * v.x() + myT * v.y() + myN * v.z());//.normalized(); //normalize for rounded errors...
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief 
	///////////////////////////////////////////////////////////////////////////
	static real cosTheta(const Vector3d& v)
	{
		return v.z();
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	static real cosTheta2(const Vector3d& v)
	{
		return v.z() * v.z();
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	static real sinTheta2(const Vector3d& v)
	{
		return 1.f - v.z() * v.z();
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief 
	///////////////////////////////////////////////////////////////////////////
	static real sinTheta(const Vector3d& v)
	{
		real sinT2 = sinTheta2(v);
		if (sinT2 < 0.f)
			return 0.f;
		return std::sqrt(sinT2);
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief
	///////////////////////////////////////////////////////////////////////////
	static real tanTheta(const Vector3d& v)
	{
		//sqrt(sin2) / cos
		//But it is rewritten in in case the compiler wouldn't optimize
		real sin2 = 1.f - v.z() * v.z();
		if (sin2 <= 0.f)
			return 0.f;
		return std::sqrt(sin2) / v.z();
	}

	static real tanTheta2(const Vector3d& v)
	{
		//sqrt(sin2) / cos2
		//But it is rewritten in in case the compiler wouldn't optimize
		real sin2 = 1.f - v.z() * v.z();
		if (sin2 <= 0.f)
			return 0.f;
		return sin2 / (v.z() * v.z());
	}

	//Local frame 
	Vector3d myS;
	Vector3d myT;
	Normal3d myN;

	//tangent and bitangent. Not always orthogonal
	Vector3d dpdu;
	Vector3d dpdv;
};

