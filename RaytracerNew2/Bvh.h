#pragma once

#include "Intersection.h"
#include "Primitive.h"
#include "GeometricShape.h"
#include "Geometry.h"

#include <vector>

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct BvhNode
{
public:
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW

	typedef std::shared_ptr<BvhNode> ptr;

	BvhNode() :myFirstPrimIndex(0), myNumberPrimitives(0), myAxis(0){
		//myChildren[0] = nullptr;
		//myChildren[1] = nullptr;
	}

	BoundingBox myBoundingBox;
	BvhNode::ptr myChildren[2];
	int myFirstPrimIndex;
	int myNumberPrimitives;
	int myAxis;

	void addChildren(BvhNode::ptr c1, BvhNode::ptr c2)
	{
		myChildren[0] = c1;
		myChildren[1] = c2;
	}
};

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct LinearBVHNode
{
	LinearBVHNode() :myFirstPrimIndex(0), myNumberPrimitives(0), myAxis(0), myRightChild(-1) {
	}

	//6 * 8 = 48 bytes
	BoundingBox myBoundingBox;

	//16 bytes
	int32_t myAxis;
	int32_t myFirstPrimIndex;
	int32_t myNumberPrimitives;
	int32_t myRightChild;
};

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct BvhData
{
	BvhData(int index, const BoundingBox& box, const Point3d& centroid) :myObjectIndex(index), myBox(box), myCentroid(centroid) {}
	int myObjectIndex;
	BoundingBox myBox;
	Point3d myCentroid;
};

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct Bin
{
	Bin() :myNumberPrimitives(0) {}

	static const int BIN_NUMBER = 16;
	int myNumberPrimitives;
	BoundingBox myBox;
};


///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct CmpBin
{
	CmpBin(real binC, real minP, int bestInd, int ax)
	{
		bestIndex = bestInd;
		binConstant = binC;
		axis = ax;
		minPos = minP;
	}

	int bestIndex;
	real binConstant;
	int axis;
	real minPos;
	bool operator() (IPrimitive::ptr p)
	{
		int index = std::min(std::max((int)((p->getCentroid()[axis] - minPos) * binConstant), 0), Bin::BIN_NUMBER - 1);
		return index <= bestIndex;
	}
};

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
class Bvh : public AccelStructure
{
public:
	enum SplitMethod
	{
		MIDDLE_POINT,
		MEDIAN,
		SAH
	};

	enum Axis : int
	{
		X_AXIS,
		Y_AXIS,
		Z_AXIS
	};

public:
	///////////////////////////////////////////////////////////////////////////
	/// \brief Default constructor.
	///////////////////////////////////////////////////////////////////////////
	Bvh();

	///////////////////////////////////////////////////////////////////////////
	/// \brief Constructor.
	///////////////////////////////////////////////////////////////////////////
	Bvh(std::vector<IPrimitive::ptr>& _primitives);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Destructor.
	///////////////////////////////////////////////////////////////////////////
	~Bvh();

	///////////////////////////////////////////////////////////////////////////
	/// \brief Main entry point to build the tree.
	///////////////////////////////////////////////////////////////////////////
	void build();

	///////////////////////////////////////////////////////////////////////////
	/// \brief Recursive calls to build a very precise tree. (But slow to build).
	///////////////////////////////////////////////////////////////////////////
	void buildNode(int startIndex, int endIndex, BvhNode::ptr currentNode, const std::vector<BvhData, Eigen::aligned_allocator<BvhData>>& data, int numberNode);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Computes the axis having the largest extent.
	///////////////////////////////////////////////////////////////////////////
	Axis getLargestAxisExtent(const BoundingBox& box);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Compute the centroid of the box.
	///////////////////////////////////////////////////////////////////////////
	real midPoint(Axis axis, const BoundingBox& box);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Specialized intersection routine.
	///////////////////////////////////////////////////////////////////////////
	bool intersection(const Ray& ray, Intersection& inter, bool shadowRay = false) override;

	///////////////////////////////////////////////////////////////////////////
	/// \brief Gets the bounding box defined by the primitives owned by the BVH tree.
	///////////////////////////////////////////////////////////////////////////
	BoundingBox getWorldBoundingBox() override
	{
		return root->myBoundingBox;
	}

	///////////////////////////////////////////////////////////////////////////
	/// \brief Computes the primitive centroid.
	///
	/// \return The centroid.
	///////////////////////////////////////////////////////////////////////////
	virtual Point3d getCentroid() { return root->myBoundingBox.getCentroid(); }


	///////////////////////////////////////////////////////////////////////////
	/// \brief Linearize the tree for faster intersection computations.
	///////////////////////////////////////////////////////////////////////////
	int flatten(BvhNode& node, int* current);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Recursive calls to build the tree. Fast and good quality.
	///////////////////////////////////////////////////////////////////////////
	void buildBinNode(int startIndex, int endIndex, BvhNode::ptr currentNode, const std::vector<BvhData, Eigen::aligned_allocator<BvhData>>& data, int numberNode);

	void initialize(Scene& scene) override;

protected:
	int myPrimitivesPerNode;

	BvhNode::ptr root;
	std::vector<LinearBVHNode, Eigen::aligned_allocator<LinearBVHNode>> myNodes;

	std::vector<IPrimitive::ptr> myPrimitives;

	SplitMethod mySplitHeuristic;

	int myNumberOfNodes;

	const real INTERSECTION_COST;

	const real TRAVERSAL_COST;

	//Bin myBins[Bin::BIN_NUMBER];
};

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct StackIntersection
{
	StackIntersection(BvhNode::ptr _node, real _t) :node(_node), t(_t) {}
	BvhNode::ptr node;
	real t;
};

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////
struct sortAxis
{
	sortAxis(Bvh::Axis axis) :myAxis(axis){}

	bool operator () (IPrimitive::ptr o1, IPrimitive::ptr o2)
	{
		Point3d centroidO1 = o1->getWorldBoundingBox().getCentroid();
		Point3d centroidO2 = o2->getWorldBoundingBox().getCentroid();

		if (centroidO1((int) myAxis) < centroidO2((int) myAxis))
				return true;
			return false;
	}

	Bvh::Axis myAxis;
};