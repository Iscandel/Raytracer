#pragma once

#include "Light.h"
#include "DirectionalLight.h"
#include "Ray.h"
#include "Color.h"
#include "Camera.h"
#include "GeometricShape.h"
#include "ObjectFactoryManager.h"
#include "System.h"
#include "JobManager.h"
#include "Sampler.h"
#include "Primitive.h"
#include "Integrator.h"

#include <vector>
#include <Eigen/StdVector>



class Bvh;

///////////////////////////////////////////////////////////////////////////////
/// \brief This class stores data and handles the ray tracing.
///////////////////////////////////////////////////////////////////////////////
class Scene
{
public:
	typedef std::vector<Light::ptr, Eigen::aligned_allocator<Light::ptr>> LightVector;
public:
	///////////////////////////////////////////////////////////////////////////////
	/// \brief Constructor
	///////////////////////////////////////////////////////////////////////////////
	Scene(void);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Destructor
	///////////////////////////////////////////////////////////////////////////////
	~Scene(void);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Computes the scene
	///////////////////////////////////////////////////////////////////////////////
	void compute(const std::string& filePath);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Casts a ray into the scene.
	/// 
	/// \param ray The ray to cast
	///
	/// \param level the level of recursion reached after reflections
	///////////////////////////////////////////////////////////////////////////////
	//Color castRay(const Ray& ray, int level);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Computes the intersection between the give ray and a possible
	/// material.
	/// 
	/// \param ray The ray to cast
	///
	/// \param dist The distance of the intersection
	///
	/// \return nullptr if there was no tersection, the considered object otherwise
	///////////////////////////////////////////////////////////////////////////////
	bool computeIntersection(const Ray& ray, Intersection& inter, bool shadowRay = false) const;

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Affects a new integrator for rendering purpose.
	/// 
	/// \param integrator The integrator to be used.
	///////////////////////////////////////////////////////////////////////////////
	void addIntegrator(Integrator::ptr integrator) { myIntegrator = integrator; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Returns the integrator used for rendering.
	/// 
	/// \return The integrator that is used.
	///////////////////////////////////////////////////////////////////////////////
	Integrator::ptr getIntegrator() { return myIntegrator; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Adds a new primitive to the scene.
	/// 
	/// \param object The primitive to add.
	///////////////////////////////////////////////////////////////////////////////
	void addPrimitive(IPrimitive::ptr object);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Adds a new light to the scene.
	/// 
	/// \param light The light to add.
	///////////////////////////////////////////////////////////////////////////////
	void addLight(Light::ptr light) {myLights.push_back(light);}

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Returns the light set used in the scene.
	/// 
	/// \return A vector containing all lights.
	///////////////////////////////////////////////////////////////////////////////
	const LightVector& getLights() const { return myLights; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Returns the camera used in the scene.
	/// 
	/// \return A reference to the camera defined for this scene.
	///////////////////////////////////////////////////////////////////////////////
	Camera& getCamera() {return *myCamera;}

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Sets the camera used in the scene.
	/// 
	/// \param 
	///////////////////////////////////////////////////////////////////////////////
	void setCamera(Camera::ptr camera) { myCamera = camera; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Sets the number of threads to used for the rendering.
	/// 
	/// \param number The number Of threads.
	///////////////////////////////////////////////////////////////////////////////
	void setThreadNumber(int number) {myManager.setThreadNumber(number);}

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Defines the number of samples per pixel.
	/// 
	/// \param samplesPerPixel The number of samples used for each pixel.
	///////////////////////////////////////////////////////////////////////////////
	void setSamplesPerPixel(int samplesPerPixel);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Returns the screen object, containing the computed image.
	/// 
	/// \return A reference to the screen
	///////////////////////////////////////////////////////////////////////////////
	Screen& getScreen() {return myCamera->getScreen();}

	Light::ptr getEnvironmentLight() { return myEnvironmentLight; }

	void setEnvironementLight(Light::ptr light) { myEnvironmentLight = light; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Affects a new sampler to the scene.
	/// 
	/// \param sampler The sampler to be used.
	///////////////////////////////////////////////////////////////////////////////
	void setSampler(Sampler::ptr sampler) ;

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Sets the block size. During the rendering, the image to be calculated
	/// is divided into independant blocks. While block are available, the different 
	/// threads peek one to compute the corresponding sub-image.
	/// 
	/// \param sizeX The X size of the block.
	/// \param sizeY The Y size of the block.
	///////////////////////////////////////////////////////////////////////////////
	void setBlockSize(int sizeX, int sizeY);

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Defines a file name to save the final image. If the name if empty, 
	/// the image is not saved.
	/// 
	/// \param filename Path to the image to save with a chosen extension.
	///////////////////////////////////////////////////////////////////////////////
	void setFileName(const std::string& filename) { myFileName = filename; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Returns the path + file name of the image to save.
	/// 
	/// \return The file name.
	///////////////////////////////////////////////////////////////////////////////
	const std::string& getFileName() const { return myFileName; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Returns the main sampler used.
	/// 
	/// \return The sampler
	///////////////////////////////////////////////////////////////////////////////
	Sampler::ptr getSampler() { return mySampler; }

	///////////////////////////////////////////////////////////////////////////////
	/// \brief Initializes the scene.
	///////////////////////////////////////////////////////////////////////////////
	void initialize();

	const BoundingBox& getBoundingBox() const { return myBoundingBox; }

	void setShowProgress(bool show);

protected:
	Camera::ptr myCamera;

	std::vector<IPrimitive::ptr> myObjects;

	LightVector myLights;

	Light::ptr myEnvironmentLight;

	Sampler::ptr mySampler;

	std::unique_ptr<AccelStructure> myAccelerator;

	Integrator::ptr myIntegrator;

	std::string myFileName;

	Point2i myBlockSize;

	BoundingBox myBoundingBox;

public:
	JobManager myManager;
};